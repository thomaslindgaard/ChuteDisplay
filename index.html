<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chute Status Display</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background-color: #f0f0f0;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .header {
        background-color: #2c3e50;
        color: white;
        text-align: center;
        padding: 15px 0;
        font-size: 2rem;
        font-weight: bold;
        flex-shrink: 0;
      }

      .main-container {
        flex: 1;
        display: flex;
        padding: 10px;
      }

      .chute-grid {
        width: 100%;
        height: 100%;
        display: grid;
        gap: 8px;
        align-content: center;
        justify-content: center;
        /* Grid layout will be set dynamically via JavaScript */
      }

      .chute-box {
        background-color: #27ae60;
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        color: white;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s ease;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        /* Size will be set dynamically via JavaScript */
      }

      .chute-box:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
      }

      .chute-name {
        font-size: 1.2rem;
        margin-bottom: 5px;
        font-weight: bold;
        letter-spacing: 0.5px;
      }

      .chute-count {
        font-size: 1.5rem;
        font-weight: normal;
      }

      .chute-count {
        text-align: right;
        align-self: flex-end;
      }

      /* Chute status colors */
      .chute-normal {
        background-color: #27ae60;
      }

      .chute-blocked {
        background-color: #e74c3c;
      }

      .chute-full {
        background-color: #f39c12;
      }

      .legend {
        background-color: white;
        border-radius: 10px 10px 0 0;
        padding: 15px 20px;
        box-shadow: 0 -2px 6px rgba(0, 0, 0, 0.1);
        width: 100%;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 40px;
      }

      .legend h3 {
        margin: 0 20px 0 0;
        color: #2c3e50;
        font-size: 1.1rem;
      }

      .legend-items {
        display: flex;
        gap: 30px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin: 0;
      }

      .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        margin-right: 10px;
      }

      .legend-normal {
        background-color: #27ae60;
      }

      .legend-blocked {
        background-color: #e74c3c;
      }

      .legend-full {
        background-color: #f39c12;
      }

      .legend-text {
        color: #2c3e50;
        font-weight: 500;
      }

      /* Responsive adjustments */
      @media (max-width: 600px) {
        .legend {
          flex-direction: column;
          gap: 15px;
        }

        .legend h3 {
          margin: 0 0 10px 0;
        }

        .legend-items {
          gap: 20px;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">Chute Status</div>

    <div class="main-container">
      <div class="chute-grid" id="chuteGrid">
        <!-- Chutes will be dynamically generated here -->
      </div>
    </div>

    <div class="legend">
      <h3>Status Legend</h3>
      <div class="legend-items">
        <div class="legend-item">
          <div class="legend-color legend-normal"></div>
          <span class="legend-text">Normal</span>
        </div>
        <div class="legend-item">
          <div class="legend-color legend-full"></div>
          <span class="legend-text">Full</span>
        </div>
        <div class="legend-item">
          <div class="legend-color legend-blocked"></div>
          <span class="legend-text">Blocked</span>
        </div>
      </div>
    </div>

    <script>
      // Get configuration from URL parameters
      function getConfigFromURL() {
        const urlParams = new URLSearchParams(window.location.search);

        // Get number of chutes
        let numChutes = 112; // Default
        const chuteParam = urlParams.get("chutes");
        if (chuteParam) {
          const parsed = parseInt(chuteParam);
          if (parsed > 0 && parsed <= 1000) {
            numChutes = parsed;
          }
        }

        // Get number of columns override
        let columnsOverride = null;
        const colsParam = urlParams.get("columns");
        if (colsParam) {
          const parsed = parseInt(colsParam);
          if (parsed > 0 && parsed <= numChutes && parsed % 10 === 0) {
            columnsOverride = parsed;
          }
        }

        return { numChutes, columnsOverride };
      }

      // Configuration
      const config = getConfigFromURL();
      const NUM_CHUTES = config.numChutes;
      const COLUMNS_OVERRIDE = config.columnsOverride;

      // Calculate optimal grid layout based on screen size and number of chutes
      function calculateGridLayout() {
        const grid = document.getElementById("chuteGrid");

        // Get actual viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Account for header height and padding
        const header = document.querySelector(".header");
        const headerHeight = header ? header.offsetHeight : 0;

        // Calculate available space for the grid - use maximum viewport space
        const legend = document.querySelector(".legend");
        const legendHeight = legend ? legend.offsetHeight : 60; // Legend height
        const padding = 20; // Minimal padding (10px on each side)

        const availableWidth = viewportWidth - padding;
        const availableHeight =
          viewportHeight - headerHeight - legendHeight - padding;

        // Find optimal grid dimensions
        let bestCols = 1;
        let bestRows = NUM_CHUTES;
        let bestChuteSize = 0;
        let bestChuteWidth = 0;
        let bestChuteHeight = 0;

        // Use column override if specified, otherwise try different configurations
        let columnsToTry;
        if (COLUMNS_OVERRIDE) {
          columnsToTry = [COLUMNS_OVERRIDE];
        } else {
          // Prioritize columns divisible by 10, then by 5, then all others
          const divisibleBy10 = [];
          const divisibleBy5 = [];
          const others = [];

          for (let i = 1; i <= NUM_CHUTES; i++) {
            if (i % 10 === 0) {
              divisibleBy10.push(i);
            } else if (i % 5 === 0) {
              divisibleBy5.push(i);
            } else {
              others.push(i);
            }
          }

          columnsToTry = [...divisibleBy10, ...divisibleBy5, ...others];
        }

        // Try different column configurations to find the best fit
        for (const cols of columnsToTry) {
          const rows = Math.ceil(NUM_CHUTES / cols);

          // Calculate chute dimensions for this configuration
          const gapSize = 8;
          const totalGapWidth = (cols - 1) * gapSize;
          const totalGapHeight = (rows - 1) * gapSize;

          const chuteWidth = Math.floor(
            (availableWidth - totalGapWidth) / cols
          );
          const chuteHeight = Math.floor(
            (availableHeight - totalGapHeight) / rows
          );

          // Use full available height and ensure width is greater than height
          const targetHeight = chuteHeight;

          // Check if both dimensions fit and width is greater than height
          if (
            chuteWidth >= 40 &&
            targetHeight >= 25 &&
            chuteWidth > targetHeight
          ) {
            const chuteArea = chuteWidth * targetHeight;
            if (chuteArea > bestChuteSize) {
              bestCols = cols;
              bestRows = rows;
              bestChuteSize = chuteArea;
              bestChuteWidth = chuteWidth;
              bestChuteHeight = targetHeight;
            }
          }
        }

        // If no good fit found, adjust to ensure width > height
        if (bestChuteSize === 0) {
          // Start with more columns to ensure wider chutes
          bestCols = Math.ceil(Math.sqrt(NUM_CHUTES * 1.5)); // Bias toward more columns
          bestRows = Math.ceil(NUM_CHUTES / bestCols);

          const gapSize = 6; // Smaller gaps for maximum space usage
          const totalGapWidth = (bestCols - 1) * gapSize;
          const totalGapHeight = (bestRows - 1) * gapSize;

          bestChuteWidth = Math.floor(
            (availableWidth - totalGapWidth) / bestCols
          );

          // Use full available height
          bestChuteHeight = Math.floor(
            (availableHeight - totalGapHeight) / bestRows
          );

          // If width is not greater than height, increase columns until it is
          while (bestChuteWidth <= bestChuteHeight && bestCols < NUM_CHUTES) {
            bestCols++;
            bestRows = Math.ceil(NUM_CHUTES / bestCols);
            const newTotalGapWidth = (bestCols - 1) * gapSize;
            const newTotalGapHeight = (bestRows - 1) * gapSize;

            bestChuteWidth = Math.floor(
              (availableWidth - newTotalGapWidth) / bestCols
            );
            bestChuteHeight = Math.floor(
              (availableHeight - newTotalGapHeight) / bestRows
            );
          }

          bestChuteSize = bestChuteWidth * bestChuteHeight;

          // Update gap size in CSS
          grid.style.gap = gapSize + "px";
        } else {
          grid.style.gap = "8px";
        }

        // Ensure minimum readable size while maximizing space usage
        bestChuteWidth = Math.max(bestChuteWidth, 40);
        bestChuteHeight = Math.max(bestChuteHeight, 25);

        // Apply the calculated layout
        grid.style.gridTemplateColumns = `repeat(${bestCols}, ${bestChuteWidth}px)`;
        grid.style.gridTemplateRows = `repeat(${bestRows}, ${bestChuteHeight}px)`;
        grid.style.justifyContent = "center";
        grid.style.alignContent = "center";

        // Calculate font sizes based on chute dimensions - larger for rectangular chutes
        const baseFontSize = Math.min(bestChuteWidth, bestChuteHeight) * 0.15;
        const nameFontSize = Math.max(baseFontSize * 1.2, 12); // Larger font for chute names
        const countFontSize = Math.max(baseFontSize, 10);

        // Apply dynamic styles to all chute boxes
        const chuteBoxes = document.querySelectorAll(".chute-box");
        chuteBoxes.forEach((box) => {
          box.style.width = bestChuteWidth + "px";
          box.style.height = bestChuteHeight + "px";
          box.style.padding =
            Math.max(Math.min(bestChuteWidth, bestChuteHeight) * 0.08, 6) +
            "px";
          box.style.borderRadius =
            Math.max(Math.min(bestChuteWidth, bestChuteHeight) * 0.08, 6) +
            "px";

          const nameEl = box.querySelector(".chute-name");
          const countEl = box.querySelector(".chute-count");

          if (nameEl) nameEl.style.fontSize = nameFontSize + "px";
          if (countEl) countEl.style.fontSize = countFontSize + "px";
        });

        console.log(
          `Grid: ${bestCols}x${bestRows}, Chute size: ${bestChuteWidth}x${bestChuteHeight}px, Total chutes: ${NUM_CHUTES}`
        );
        if (COLUMNS_OVERRIDE) {
          console.log(`Using column override: ${COLUMNS_OVERRIDE} columns`);
        } else {
          console.log(`Automatically calculated layout for optimal display`);
        }
      }

      // Generate chute data with random statuses and counts for demonstration
      function generateChuteData() {
        const chutes = [];
        const statuses = ["normal", "blocked", "full"];

        for (let i = 1; i <= NUM_CHUTES; i++) {
          const chuteNumber = i.toString().padStart(4, "0");
          const status = statuses[Math.floor(Math.random() * statuses.length)];
          const itemCount =
            status === "blocked" ? 0 : Math.floor(Math.random() * 100);

          chutes.push({
            name: `CHU${chuteNumber}`,
            count: itemCount,
            status: status,
          });
        }

        return chutes;
      }

      // Render chutes to the grid
      function renderChutes(chutes) {
        const grid = document.getElementById("chuteGrid");
        grid.innerHTML = "";

        chutes.forEach((chute) => {
          const chuteElement = document.createElement("div");
          chuteElement.className = `chute-box chute-${chute.status}`;

          chuteElement.innerHTML = `
                    <div class="chute-name">${chute.name}</div>
                    <div class="chute-count">${chute.count}</div>
                `;

          grid.appendChild(chuteElement);
        });

        // Calculate and apply optimal layout after rendering
        setTimeout(calculateGridLayout, 0);
      }

      // Update chute data periodically (simulation)
      function updateChutes() {
        const chutes = generateChuteData();
        renderChutes(chutes);
      }

      // Initialize the display
      updateChutes();

      // Recalculate layout on window resize
      window.addEventListener("resize", () => {
        setTimeout(calculateGridLayout, 100);
      });

      // Update every 5 seconds for demonstration
      setInterval(updateChutes, 5000);

      // Optional: Add click handlers for chutes
      document
        .getElementById("chuteGrid")
        .addEventListener("click", function (e) {
          const chuteBox = e.target.closest(".chute-box");
          if (chuteBox) {
            const chuteName = chuteBox.querySelector(".chute-name").textContent;
            console.log(`Clicked on ${chuteName}`);
            // Add any additional interaction logic here
          }
        });
    </script>
  </body>
</html>
